package install

import (
	"bufio"
	"github.com/genshen/pkg"
	"github.com/genshen/pkg/pkg/version"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type cmakeDepData struct {
	LibName           string
	PkgHome           string
	SrcDir            string
	PkgDir            string
	InnerBuildCommand []string
	OuterBuildCommand []string
	InnerCMake        string
	OuterCMake        string
}

const VendorPathReplace = "VENDOR_PATH_REPLACE"
const PkgCMakeHeader = `##### this file is generated by pkg tool, version ` + version.VERSION +
	`
##### For more details, please address https://github.com/genshen/pkg.

# vendor path
# you should change VENDOR_PATH if you moved this directory to other place.
set(VENDOR_PATH VENDOR_PATH_REPLACE)
include_directories(${VENDOR_PATH}/include)
`

const CmakeToFile = `
# lib {{.LibName}}
# src: {{.SrcDir}}
# pkg: {{.PkgDir}}
# build command:
#     inner build command: {{.InnerBuildCommand}}
#     outer build command: {{.OuterBuildCommand}}
{{.InnerCMake}} # inner cmake
{{.OuterCMake}} # outer cmake
`

// pkgHome is always pkg root.
func createPkgDepCmake(pkgHome, srcHome string, depTree *pkg.DependencyTree) error {
	// create dep cmake file only for pkg based project.
	if !depTree.IsPkgPackage {
		return nil
	}

	// create cmake dep file for this package.
	if cmakeDepWriter, err := os.Create(filepath.Join(srcHome, pkg.CMakeDep)); err != nil {
		return err
	} else {
		pkgCMakeLibSet := make(map[string]bool)
		defer cmakeDepWriter.Close()
		bufWriter := bufio.NewWriter(cmakeDepWriter)

		// for all package, set @PkgHome/vendor as vendor home.
		bufWriter.WriteString(strings.Replace(PkgCMakeHeader, VendorPathReplace, pkg.GetVendorPath(pkgHome), -1))
		if err := cmakeLib(depTree, pkgHome, true, &pkgCMakeLibSet, bufWriter); err != nil {
			return err
		}
		bufWriter.Flush()
		log.Println("generated cmake for package", depTree.Context.PackageName)
	}
	// create cmake dep file for all its sub/child package.
	for _, v := range depTree.Dependencies {
		// for all non-root package, the srcHome is pkgHome/vendor/src/@packageName
		err := createPkgDepCmake(pkgHome, pkg.GetPackageSrcPath(pkgHome, v.Context.PackageName), v)
		if err != nil {
			return err // break loop.
		}
	}
	return nil
}

// todo combine this function anf function buildPkg.
// root: indicating the root package
// pkgHome: absolute path for pkg home.
func cmakeLib(dep *pkg.DependencyTree, pkgHome string, root bool, cmakeLibSet *map[string]bool, writer io.Writer) error {
	// if this package has been built, skip it and its dependency.
	if _, ok := (*cmakeLibSet)[dep.Context.PackageName]; ok {
		return nil
	}

	for _, v := range dep.Dependencies {
		if err := cmakeLib(v, pkgHome, false, cmakeLibSet, writer); err != nil {
			return err // break loop.
		}
	}

	// do not generate cmake include script for root lib.
	if root {
		return nil
	}
	pkg.AddVendorPathEnv("")                // relative path.
	pkg.AddPathEnv(dep.Context.PackageName) // add vars for this package, using relative path.
	// generating cmake script.
	toFile := cmakeDepData{
		LibName:    dep.Context.PackageName,
		InnerCMake: dep.SelfCMakeLib,
		OuterCMake: dep.CMakeLib,
		PkgHome:    pkgHome,
		SrcDir:     pkg.GetPackageSrcPath("", dep.Context.PackageName), // use relative path.
		PkgDir:     pkg.GetPkgPath("", dep.Context.PackageName),
	}
	// copy slice, don't modify the original data.
	toFile.OuterBuildCommand = make([]string, len(dep.Builder))
	toFile.InnerBuildCommand = make([]string, len(dep.SelfBuild))
	copy(toFile.OuterBuildCommand, dep.Builder)
	copy(toFile.InnerBuildCommand, dep.SelfBuild)

	if dep.CMakeLib != "" { // ignore self cmake if the cmake in override by outer cmake lib.
		toFile.InnerCMake = ""
	}
	if err := genCMake(toFile, writer); err != nil {
		return err
	}
	(*cmakeLibSet)[dep.Context.PackageName] = true
	return nil
}

func genCMake(cmake cmakeDepData, writer io.Writer) error {
	if cmake.InnerCMake == "" && cmake.OuterCMake == "" {
		return nil
	}
	cmake.InnerCMake = pkg.ProcessEnv(cmake.InnerCMake)
	cmake.OuterCMake = pkg.ProcessEnv(cmake.OuterCMake)
	// InnerBuildCommand and OuterBuildCommand is just used in comment.
	for i, v := range cmake.InnerBuildCommand {
		cmake.InnerBuildCommand[i] = pkg.ProcessEnv(v)
	}
	for i, v := range cmake.OuterBuildCommand {
		cmake.OuterBuildCommand[i] = pkg.ProcessEnv(v)
	}

	// render template.
	if t, err := template.New("cmake").Parse(CmakeToFile); err != nil {
		return err
	} else {
		if err := t.Execute(writer, cmake); err != nil {
			return err
		}
	}
	return nil
}
